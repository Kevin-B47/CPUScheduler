package cpuc;


import java.awt.Color;
import java.awt.Container;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import java.util.Random;
import java.util.Set;
import java.util.TreeMap;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import static javax.swing.JOptionPane.WARNING_MESSAGE;
import javax.swing.JPanel;
import javax.swing.JTextField;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Kevin Block
 * SJC
 * Operating Systems
 */
public class Sched extends javax.swing.JFrame {
    DecimalFormat df = new DecimalFormat(".##"); // decimal format which helps with doubles
    /**
     * Creates new form Sched
     */
    public Sched() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTabbedPane1 = new javax.swing.JTabbedPane();
        welcomeTab = new javax.swing.JPanel();
        welcomeLbl = new java.awt.Label();
        dirLbl = new java.awt.Label();
        dirLbl1 = new java.awt.Label();
        dirLbl2 = new java.awt.Label();
        dirLbl3 = new java.awt.Label();
        dirLbl4 = new java.awt.Label();
        dirLblClass = new java.awt.Label();
        rbTab = new javax.swing.JPanel();
        rndLbl = new java.awt.Label();
        rrProgress = new javax.swing.JPanel();
        rrProcess1 = new javax.swing.JTextField();
        rrProcess2 = new javax.swing.JTextField();
        rrProcess3 = new javax.swing.JTextField();
        rrProcess4 = new javax.swing.JTextField();
        rrProcess5 = new javax.swing.JTextField();
        rrState = new java.awt.Label();
        rrQuant = new javax.swing.JTextField();
        lblrrQuant = new javax.swing.JLabel();
        lblrrProcess1 = new javax.swing.JLabel();
        lblrrProcess2 = new javax.swing.JLabel();
        lblrrProcess3 = new javax.swing.JLabel();
        lblrrProcess4 = new javax.swing.JLabel();
        lblrrProcess5 = new javax.swing.JLabel();
        rrRandom = new javax.swing.JButton();
        rrReset = new javax.swing.JButton();
        rrExecute = new javax.swing.JButton();
        rrlblWait = new javax.swing.JLabel();
        rrlblTurn = new javax.swing.JLabel();
        rrMaxQuant = new java.awt.Label();
        rrMaxBurst = new java.awt.Label();
        fcfsTab = new javax.swing.JPanel();
        fcfsLbl = new java.awt.Label();
        lblfcfsProcess1 = new javax.swing.JLabel();
        lblfcfsProcess2 = new javax.swing.JLabel();
        lblfcfsProcess3 = new javax.swing.JLabel();
        lblfcfsProcess4 = new javax.swing.JLabel();
        lblfcfsProcess5 = new javax.swing.JLabel();
        fcfsProcess5 = new javax.swing.JTextField();
        fcfsProcess4 = new javax.swing.JTextField();
        fcfsProcess3 = new javax.swing.JTextField();
        fcfsProcess2 = new javax.swing.JTextField();
        fcfsProcess1 = new javax.swing.JTextField();
        fcfsWaitTime = new javax.swing.JLabel();
        fcfsTurnAround = new javax.swing.JLabel();
        fcfsRandom = new javax.swing.JButton();
        fcfsReset = new javax.swing.JButton();
        fcfsExecute = new javax.swing.JButton();
        lbllfcfsMaxBurst = new java.awt.Label();
        lbllfcfsState = new java.awt.Label();
        fcfsProgress = new javax.swing.JPanel();
        sjfTab = new javax.swing.JPanel();
        label1 = new java.awt.Label();
        sjfState = new java.awt.Label();
        sjfBTMax = new java.awt.Label();
        sjflblProcess1 = new javax.swing.JLabel();
        sjfProcess1 = new javax.swing.JTextField();
        sjflblProcess2 = new javax.swing.JLabel();
        sjfProcess2 = new javax.swing.JTextField();
        sjflblProcess3 = new javax.swing.JLabel();
        sjfProcess3 = new javax.swing.JTextField();
        sjflblProcess4 = new javax.swing.JLabel();
        sjfProcess4 = new javax.swing.JTextField();
        sjflblProcess5 = new javax.swing.JLabel();
        sjfProcess5 = new javax.swing.JTextField();
        sjfRandomize = new javax.swing.JButton();
        sjfReset = new javax.swing.JButton();
        sjfExecute = new javax.swing.JButton();
        sjfWaitTime = new javax.swing.JLabel();
        sjfTurnAround = new javax.swing.JLabel();
        sjfProgress = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jTabbedPane1.setBackground(new java.awt.Color(33, 33, 33));

        welcomeTab.setBackground(new java.awt.Color(33, 33, 33));

        welcomeLbl.setFont(new java.awt.Font("Arial", 0, 36)); // NOI18N
        welcomeLbl.setForeground(new java.awt.Color(255, 255, 255));
        welcomeLbl.setText("CPU Scheduler");

        dirLbl.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        dirLbl.setForeground(new java.awt.Color(255, 255, 255));
        dirLbl.setText("To begin, pick an algorithim in the top panel! Here is a brief description of the alorigthims and the rules set");

        dirLbl1.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        dirLbl1.setForeground(new java.awt.Color(255, 255, 255));
        dirLbl1.setText("Round Robin: This algorithim uses time sharing of the CPU clock to give each process a time slot or quantum");

        dirLbl2.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        dirLbl2.setForeground(new java.awt.Color(255, 255, 255));
        dirLbl2.setText("First Come First Serve:  This algorithim executes jobs as the come in, regardless of size");

        dirLbl3.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        dirLbl3.setForeground(new java.awt.Color(255, 255, 255));
        dirLbl3.setText("Shortest Job First: This algorithim executes all jobs starting with the shortest jobs first for a better wait time");

        dirLbl4.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        dirLbl4.setForeground(new java.awt.Color(255, 255, 255));
        dirLbl4.setText("Kevin Block");

        dirLblClass.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        dirLblClass.setForeground(new java.awt.Color(255, 255, 255));
        dirLblClass.setText("COM 310");

        javax.swing.GroupLayout welcomeTabLayout = new javax.swing.GroupLayout(welcomeTab);
        welcomeTab.setLayout(welcomeTabLayout);
        welcomeTabLayout.setHorizontalGroup(
            welcomeTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(welcomeTabLayout.createSequentialGroup()
                .addGroup(welcomeTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(welcomeTabLayout.createSequentialGroup()
                        .addGap(20, 20, 20)
                        .addGroup(welcomeTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(welcomeLbl, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(dirLbl, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(dirLbl1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(dirLbl2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(dirLbl3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(0, 81, Short.MAX_VALUE))
                    .addGroup(welcomeTabLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(dirLbl4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(dirLblClass, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        welcomeTabLayout.setVerticalGroup(
            welcomeTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, welcomeTabLayout.createSequentialGroup()
                .addGroup(welcomeTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(welcomeTabLayout.createSequentialGroup()
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(dirLblClass, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(welcomeTabLayout.createSequentialGroup()
                        .addGap(33, 33, 33)
                        .addComponent(welcomeLbl, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(69, 69, 69)
                        .addComponent(dirLbl, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(dirLbl1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(dirLbl2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(dirLbl3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 128, Short.MAX_VALUE)
                        .addComponent(dirLbl4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );

        dirLblClass.getAccessibleContext().setAccessibleName("COM 310");

        jTabbedPane1.addTab("Welcome", welcomeTab);

        rbTab.setBackground(new java.awt.Color(33, 33, 33));

        rndLbl.setFont(new java.awt.Font("Dialog", 0, 36)); // NOI18N
        rndLbl.setForeground(new java.awt.Color(255, 255, 255));
        rndLbl.setText("Round Robin");

        rrProgress.setPreferredSize(new java.awt.Dimension(750, 30));

        javax.swing.GroupLayout rrProgressLayout = new javax.swing.GroupLayout(rrProgress);
        rrProgress.setLayout(rrProgressLayout);
        rrProgressLayout.setHorizontalGroup(
            rrProgressLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 750, Short.MAX_VALUE)
        );
        rrProgressLayout.setVerticalGroup(
            rrProgressLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 30, Short.MAX_VALUE)
        );

        rrProcess2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rrProcess2ActionPerformed(evt);
            }
        });

        rrProcess5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rrProcess5ActionPerformed(evt);
            }
        });

        rrState.setForeground(new java.awt.Color(255, 255, 255));
        rrState.setText("Enter a quantum slice and the burst times. We are assuming that all processes came into the CPU at the same time");

        lblrrQuant.setForeground(new java.awt.Color(255, 255, 255));
        lblrrQuant.setLabelFor(rrQuant);
        lblrrQuant.setText("Quantum Slice");

        lblrrProcess1.setForeground(new java.awt.Color(255, 255, 255));
        lblrrProcess1.setLabelFor(rrProcess1);
        lblrrProcess1.setText("Process 1");

        lblrrProcess2.setForeground(new java.awt.Color(255, 255, 255));
        lblrrProcess2.setLabelFor(rrProcess2);
        lblrrProcess2.setText("Process 2");

        lblrrProcess3.setForeground(new java.awt.Color(255, 255, 255));
        lblrrProcess3.setLabelFor(rrProcess3);
        lblrrProcess3.setText("Process 3");

        lblrrProcess4.setForeground(new java.awt.Color(255, 255, 255));
        lblrrProcess4.setLabelFor(lblrrProcess3);
        lblrrProcess4.setText("Process 4");

        lblrrProcess5.setForeground(new java.awt.Color(255, 255, 255));
        lblrrProcess5.setLabelFor(rrProcess5);
        lblrrProcess5.setText("Process 5");

        rrRandom.setText("Randomize");
        rrRandom.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                rrRandomMouseClicked(evt);
            }
        });
        rrRandom.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rrRandomActionPerformed(evt);
            }
        });

        rrReset.setText("Reset");
        rrReset.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rrResetActionPerformed(evt);
            }
        });

        rrExecute.setText("Execute");
        rrExecute.setToolTipText("");
        rrExecute.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rrExecuteActionPerformed(evt);
            }
        });

        rrlblWait.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        rrlblWait.setForeground(new java.awt.Color(255, 255, 255));
        rrlblWait.setText("Average Waiting Time: ");

        rrlblTurn.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        rrlblTurn.setForeground(new java.awt.Color(255, 255, 255));
        rrlblTurn.setText("Average Turnaround: ");

        rrMaxQuant.setForeground(new java.awt.Color(255, 255, 255));
        rrMaxQuant.setText("Quantum Slice ( 1 - 10 )");

        rrMaxBurst.setForeground(new java.awt.Color(255, 255, 255));
        rrMaxBurst.setText("Burst Times ( 1 - 20 )");

        javax.swing.GroupLayout rbTabLayout = new javax.swing.GroupLayout(rbTab);
        rbTab.setLayout(rbTabLayout);
        rbTabLayout.setHorizontalGroup(
            rbTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(rbTabLayout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addGroup(rbTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(rndLbl, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(rrState, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(rbTabLayout.createSequentialGroup()
                        .addGroup(rbTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(rbTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                .addComponent(lblrrProcess2)
                                .addComponent(lblrrProcess1)
                                .addComponent(lblrrProcess3)
                                .addComponent(lblrrProcess4)
                                .addComponent(lblrrProcess5))
                            .addComponent(lblrrQuant, javax.swing.GroupLayout.PREFERRED_SIZE, 98, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(rrMaxQuant, javax.swing.GroupLayout.PREFERRED_SIZE, 144, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(rbTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(rbTabLayout.createSequentialGroup()
                                .addGroup(rbTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(rrProcess2)
                                    .addComponent(rrProcess1)
                                    .addComponent(rrProcess3)
                                    .addComponent(rrProcess4)
                                    .addComponent(rrProcess5)
                                    .addComponent(rrQuant, javax.swing.GroupLayout.PREFERRED_SIZE, 125, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addGap(117, 117, 117)
                                .addGroup(rbTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addGroup(rbTabLayout.createSequentialGroup()
                                        .addComponent(rrRandom)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(rrReset, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                        .addComponent(rrExecute))
                                    .addComponent(rrlblTurn)
                                    .addComponent(rrlblWait)))
                            .addComponent(rrMaxBurst, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addComponent(rrProgress, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(28, Short.MAX_VALUE))
        );
        rbTabLayout.setVerticalGroup(
            rbTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(rbTabLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(rndLbl, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(2, 2, 2)
                .addComponent(rrState, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(rbTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(rrMaxQuant, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(rrMaxBurst, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(39, 39, 39)
                .addGroup(rbTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                    .addGroup(rbTabLayout.createSequentialGroup()
                        .addComponent(rrlblTurn)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(rrlblWait)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(rbTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(rrReset)
                            .addComponent(rrExecute)
                            .addComponent(rrRandom)))
                    .addGroup(rbTabLayout.createSequentialGroup()
                        .addGroup(rbTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(rrQuant, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblrrQuant))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(rbTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(rrProcess1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblrrProcess1))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(rbTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(rrProcess2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblrrProcess2))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(rbTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(rrProcess3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblrrProcess3))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(rbTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(rrProcess4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblrrProcess4))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(rbTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(rrProcess5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblrrProcess5))))
                .addGap(33, 33, 33)
                .addComponent(rrProgress, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(52, Short.MAX_VALUE))
        );

        rrState.getAccessibleContext().setAccessibleName("");
        rrMaxQuant.getAccessibleContext().setAccessibleName("");

        jTabbedPane1.addTab("Round Robin", rbTab);

        fcfsTab.setBackground(new java.awt.Color(33, 33, 33));

        fcfsLbl.setFont(new java.awt.Font("Dialog", 0, 36)); // NOI18N
        fcfsLbl.setForeground(new java.awt.Color(255, 255, 255));
        fcfsLbl.setText("First Come First Serve");

        lblfcfsProcess1.setForeground(new java.awt.Color(255, 255, 255));
        lblfcfsProcess1.setLabelFor(rrProcess1);
        lblfcfsProcess1.setText("Process 1");

        lblfcfsProcess2.setForeground(new java.awt.Color(255, 255, 255));
        lblfcfsProcess2.setLabelFor(rrProcess2);
        lblfcfsProcess2.setText("Process 2");

        lblfcfsProcess3.setForeground(new java.awt.Color(255, 255, 255));
        lblfcfsProcess3.setLabelFor(rrProcess3);
        lblfcfsProcess3.setText("Process 3");

        lblfcfsProcess4.setForeground(new java.awt.Color(255, 255, 255));
        lblfcfsProcess4.setLabelFor(lblrrProcess3);
        lblfcfsProcess4.setText("Process 4");

        lblfcfsProcess5.setForeground(new java.awt.Color(255, 255, 255));
        lblfcfsProcess5.setLabelFor(rrProcess5);
        lblfcfsProcess5.setText("Process 5");

        fcfsProcess5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fcfsProcess5ActionPerformed(evt);
            }
        });

        fcfsProcess2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fcfsProcess2ActionPerformed(evt);
            }
        });

        fcfsWaitTime.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        fcfsWaitTime.setForeground(new java.awt.Color(255, 255, 255));
        fcfsWaitTime.setText("Average Waiting Time: ");

        fcfsTurnAround.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        fcfsTurnAround.setForeground(new java.awt.Color(255, 255, 255));
        fcfsTurnAround.setText("Average Turnaround: ");

        fcfsRandom.setText("Randomize");
        fcfsRandom.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                fcfsRandomMouseClicked(evt);
            }
        });
        fcfsRandom.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fcfsRandomActionPerformed(evt);
            }
        });

        fcfsReset.setText("Reset");
        fcfsReset.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fcfsResetActionPerformed(evt);
            }
        });

        fcfsExecute.setText("Execute");
        fcfsExecute.setToolTipText("");
        fcfsExecute.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                fcfsExecuteActionPerformed(evt);
            }
        });

        lbllfcfsMaxBurst.setForeground(new java.awt.Color(255, 255, 255));
        lbllfcfsMaxBurst.setText("Burst Times ( 1 - 20 )");

        lbllfcfsState.setForeground(new java.awt.Color(255, 255, 255));
        lbllfcfsState.setText("Enter the burst times for the processes. We are assuming that all processes came into the CPU at the same time");

        fcfsProgress.setPreferredSize(new java.awt.Dimension(750, 30));

        javax.swing.GroupLayout fcfsProgressLayout = new javax.swing.GroupLayout(fcfsProgress);
        fcfsProgress.setLayout(fcfsProgressLayout);
        fcfsProgressLayout.setHorizontalGroup(
            fcfsProgressLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 750, Short.MAX_VALUE)
        );
        fcfsProgressLayout.setVerticalGroup(
            fcfsProgressLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 30, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout fcfsTabLayout = new javax.swing.GroupLayout(fcfsTab);
        fcfsTab.setLayout(fcfsTabLayout);
        fcfsTabLayout.setHorizontalGroup(
            fcfsTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(fcfsTabLayout.createSequentialGroup()
                .addGap(24, 24, 24)
                .addGroup(fcfsTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(fcfsProgress, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lbllfcfsState, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(fcfsLbl, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(fcfsTabLayout.createSequentialGroup()
                        .addGroup(fcfsTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(lblfcfsProcess2)
                            .addComponent(lblfcfsProcess1)
                            .addComponent(lblfcfsProcess3)
                            .addComponent(lblfcfsProcess4)
                            .addComponent(lblfcfsProcess5))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(fcfsTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(fcfsProcess2)
                            .addComponent(fcfsProcess1)
                            .addComponent(fcfsProcess3)
                            .addComponent(fcfsProcess4)
                            .addComponent(fcfsProcess5, javax.swing.GroupLayout.PREFERRED_SIZE, 125, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(117, 117, 117)
                        .addGroup(fcfsTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(fcfsTurnAround)
                            .addComponent(fcfsWaitTime)
                            .addGroup(fcfsTabLayout.createSequentialGroup()
                                .addComponent(fcfsRandom)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(fcfsReset, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(fcfsExecute))))
                    .addComponent(lbllfcfsMaxBurst, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(26, Short.MAX_VALUE))
        );
        fcfsTabLayout.setVerticalGroup(
            fcfsTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(fcfsTabLayout.createSequentialGroup()
                .addGap(20, 20, 20)
                .addComponent(fcfsLbl, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(lbllfcfsState, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(19, 19, 19)
                .addComponent(lbllfcfsMaxBurst, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(30, 30, 30)
                .addGroup(fcfsTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(fcfsTabLayout.createSequentialGroup()
                        .addComponent(fcfsTurnAround)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(fcfsWaitTime))
                    .addGroup(fcfsTabLayout.createSequentialGroup()
                        .addGroup(fcfsTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(fcfsProcess1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblfcfsProcess1))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(fcfsTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(fcfsProcess2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblfcfsProcess2))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(fcfsTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(fcfsProcess3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblfcfsProcess3))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(fcfsTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(fcfsProcess4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblfcfsProcess4))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(fcfsTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(fcfsProcess5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(lblfcfsProcess5)
                            .addComponent(fcfsRandom)
                            .addComponent(fcfsReset)
                            .addComponent(fcfsExecute))))
                .addGap(18, 18, 18)
                .addComponent(fcfsProgress, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(77, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("First Come First Serve", fcfsTab);

        sjfTab.setBackground(new java.awt.Color(33, 33, 33));

        label1.setFont(new java.awt.Font("Arial", 0, 36)); // NOI18N
        label1.setForeground(new java.awt.Color(255, 255, 255));
        label1.setText("Shortest Job First");

        sjfState.setForeground(new java.awt.Color(255, 255, 255));
        sjfState.setText("Enter the burst times for the processes. We are assuming that all processes came into the CPU at the same time");

        sjfBTMax.setForeground(new java.awt.Color(255, 255, 255));
        sjfBTMax.setText("Burst Times ( 1 - 20 )");

        sjflblProcess1.setForeground(new java.awt.Color(255, 255, 255));
        sjflblProcess1.setLabelFor(rrProcess1);
        sjflblProcess1.setText("Process 1");

        sjflblProcess2.setForeground(new java.awt.Color(255, 255, 255));
        sjflblProcess2.setLabelFor(rrProcess2);
        sjflblProcess2.setText("Process 2");

        sjfProcess2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sjfProcess2ActionPerformed(evt);
            }
        });

        sjflblProcess3.setForeground(new java.awt.Color(255, 255, 255));
        sjflblProcess3.setLabelFor(rrProcess3);
        sjflblProcess3.setText("Process 3");

        sjflblProcess4.setForeground(new java.awt.Color(255, 255, 255));
        sjflblProcess4.setLabelFor(lblrrProcess3);
        sjflblProcess4.setText("Process 4");

        sjflblProcess5.setForeground(new java.awt.Color(255, 255, 255));
        sjflblProcess5.setLabelFor(rrProcess5);
        sjflblProcess5.setText("Process 5");

        sjfProcess5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sjfProcess5ActionPerformed(evt);
            }
        });

        sjfRandomize.setText("Randomize");
        sjfRandomize.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                sjfRandomizeMouseClicked(evt);
            }
        });
        sjfRandomize.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sjfRandomizeActionPerformed(evt);
            }
        });

        sjfReset.setText("Reset");
        sjfReset.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sjfResetActionPerformed(evt);
            }
        });

        sjfExecute.setText("Execute");
        sjfExecute.setToolTipText("");
        sjfExecute.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sjfExecuteActionPerformed(evt);
            }
        });

        sjfWaitTime.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        sjfWaitTime.setForeground(new java.awt.Color(255, 255, 255));
        sjfWaitTime.setText("Average Waiting Time: ");

        sjfTurnAround.setFont(new java.awt.Font("Arial", 0, 14)); // NOI18N
        sjfTurnAround.setForeground(new java.awt.Color(255, 255, 255));
        sjfTurnAround.setText("Average Turnaround: ");

        sjfProgress.setPreferredSize(new java.awt.Dimension(750, 30));

        javax.swing.GroupLayout sjfProgressLayout = new javax.swing.GroupLayout(sjfProgress);
        sjfProgress.setLayout(sjfProgressLayout);
        sjfProgressLayout.setHorizontalGroup(
            sjfProgressLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 750, Short.MAX_VALUE)
        );
        sjfProgressLayout.setVerticalGroup(
            sjfProgressLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 30, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout sjfTabLayout = new javax.swing.GroupLayout(sjfTab);
        sjfTab.setLayout(sjfTabLayout);
        sjfTabLayout.setHorizontalGroup(
            sjfTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(sjfTabLayout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addGroup(sjfTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(label1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(sjfState, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(sjfBTMax, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(sjfTabLayout.createSequentialGroup()
                        .addGroup(sjfTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(sjflblProcess2)
                            .addComponent(sjflblProcess1)
                            .addComponent(sjflblProcess3)
                            .addComponent(sjflblProcess4)
                            .addComponent(sjflblProcess5))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(sjfTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(sjfProcess2)
                            .addComponent(sjfProcess1)
                            .addComponent(sjfProcess3)
                            .addComponent(sjfProcess4)
                            .addComponent(sjfProcess5, javax.swing.GroupLayout.PREFERRED_SIZE, 125, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(135, 135, 135)
                        .addGroup(sjfTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(sjfTurnAround)
                            .addComponent(sjfWaitTime)
                            .addGroup(sjfTabLayout.createSequentialGroup()
                                .addComponent(sjfRandomize)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(sjfReset, javax.swing.GroupLayout.PREFERRED_SIZE, 85, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(sjfExecute))))
                    .addComponent(sjfProgress, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(28, Short.MAX_VALUE))
        );
        sjfTabLayout.setVerticalGroup(
            sjfTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(sjfTabLayout.createSequentialGroup()
                .addGap(29, 29, 29)
                .addComponent(label1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(sjfState, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(19, 19, 19)
                .addComponent(sjfBTMax, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(28, 28, 28)
                .addGroup(sjfTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(sjfTabLayout.createSequentialGroup()
                        .addComponent(sjfTurnAround)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(sjfWaitTime))
                    .addGroup(sjfTabLayout.createSequentialGroup()
                        .addGroup(sjfTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(sjfProcess1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(sjflblProcess1))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(sjfTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(sjfProcess2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(sjflblProcess2))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(sjfTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(sjfProcess3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(sjflblProcess3))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(sjfTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(sjfProcess4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(sjflblProcess4))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(sjfTabLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(sjfProcess5, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(sjflblProcess5)
                            .addComponent(sjfRandomize)
                            .addComponent(sjfReset)
                            .addComponent(sjfExecute))))
                .addGap(21, 21, 21)
                .addComponent(sjfProgress, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(71, Short.MAX_VALUE))
        );

        jTabbedPane1.addTab("Shortest Job First", sjfTab);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jTabbedPane1)
                .addGap(0, 0, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jTabbedPane1)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void rrProcess5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rrProcess5ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_rrProcess5ActionPerformed

    private void rrProcess2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rrProcess2ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_rrProcess2ActionPerformed

    private void rrRandomMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_rrRandomMouseClicked
        
       
    }//GEN-LAST:event_rrRandomMouseClicked

    private void rrRandomActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rrRandomActionPerformed
        Random randInt = new Random();
        int min = 1; // Random ints to randomize from 1 - 20
        int max = 20;

        rrQuant.setText(String.valueOf(randInt.nextInt((10 - 1) + 1) + 1));
        rrProcess1.setText(String.valueOf(randInt.nextInt((max - min) + 1) + min));
        rrProcess2.setText(String.valueOf(randInt.nextInt((max - min) + 1) + min));
        rrProcess3.setText(String.valueOf(randInt.nextInt((max - min) + 1) + min));
        rrProcess4.setText(String.valueOf(randInt.nextInt((max - min) + 1) + min));
        rrProcess5.setText(String.valueOf(randInt.nextInt((max - min) + 1) + min));
    }//GEN-LAST:event_rrRandomActionPerformed

    private void rrResetActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rrResetActionPerformed

        rrQuant.setText("");
        rrProcess1.setText("");
        rrProcess2.setText("");
        rrProcess3.setText(""); // This method resets everything to default
        rrProcess4.setText("");
        rrProcess5.setText("");
        rrlblWait.setText("Average Waiting Time: ");
        rrlblTurn.setText("Average Turnaround:  ");
        rrProgress.removeAll();
        rrProgress.invalidate();
        rrProgress.revalidate();
        rrProgress.repaint();  
        
       if (numLbls.size() > 1){
            for(int i = 0; i < numLbls.size(); i++){
                numLbls.get(i).setVisible(false);
            }
        }
        
        
    }//GEN-LAST:event_rrResetActionPerformed

    private void rrExecuteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rrExecuteActionPerformed
        javax.swing.JTextField[] textBoxes = {rrProcess1,rrProcess2,rrProcess3,rrProcess4,rrProcess5};// We will use 5 processes for now
        //javax.swing.JTextField[] textBoxes = {process1,process2,process3};
        boolean invalid = false;
        rrlblWait.setText("Average Waiting Time: "); // Executes round robin
        rrlblTurn.setText("Average Turnaround:  ");
        for (int i = 0; i < textBoxes.length; i++){
            if (textBoxes[i].getText().equalsIgnoreCase("") || !isnumber(textBoxes[i].getText())) { // Checks for nan
                JOptionPane.showMessageDialog(rootPane, "Process " + i + " has an invalid burst time", "Invalid Burst Time", WARNING_MESSAGE);
                invalid = true;
            }
        }
        
        if (!isnumber(rrQuant.getText())){
            JOptionPane.showMessageDialog(rootPane, "Quantum Slice has an invalid slice time", "Invalid Slice Time", WARNING_MESSAGE);
            invalid = true;
        }
        
        if (!invalid){
            rrlblTurn.setText(rrlblTurn.getText() + df.format(ComputeTurnAroundRoundRobin(Integer.parseInt(rrQuant.getText()),textBoxes)) + " ms");
        }
    }//GEN-LAST:event_rrExecuteActionPerformed

    private void fcfsProcess5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fcfsProcess5ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_fcfsProcess5ActionPerformed

    private void fcfsProcess2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fcfsProcess2ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_fcfsProcess2ActionPerformed

    private void fcfsRandomMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_fcfsRandomMouseClicked
        // TODO add your handling code here:
    }//GEN-LAST:event_fcfsRandomMouseClicked

    private void fcfsRandomActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fcfsRandomActionPerformed
        Random randInt = new Random();
        int min = 1;
        int max = 20;

        fcfsProcess1.setText(String.valueOf(randInt.nextInt((max - min) + 1) + min));
        fcfsProcess2.setText(String.valueOf(randInt.nextInt((max - min) + 1) + min));
        fcfsProcess3.setText(String.valueOf(randInt.nextInt((max - min) + 1) + min));
        fcfsProcess4.setText(String.valueOf(randInt.nextInt((max - min) + 1) + min));
        fcfsProcess5.setText(String.valueOf(randInt.nextInt((max - min) + 1) + min));
    }//GEN-LAST:event_fcfsRandomActionPerformed

    private void fcfsResetActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fcfsResetActionPerformed
       
        fcfsProcess1.setText("");
        fcfsProcess2.setText("");
        fcfsProcess3.setText("");
        fcfsProcess4.setText("");
        fcfsProcess5.setText("");
        fcfsWaitTime.setText("Average Waiting Time: ");
        fcfsTurnAround.setText("Average Turnaround:  ");
        fcfsProgress.removeAll();
        fcfsProgress.invalidate();
        fcfsProgress.revalidate();
        fcfsProgress.repaint();
        
         if (numLbls.size() > 1){
            for(int i = 0; i < numLbls.size(); i++){
                numLbls.get(i).setVisible(false);
            }
        }
        
    }//GEN-LAST:event_fcfsResetActionPerformed

    private void fcfsExecuteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_fcfsExecuteActionPerformed
        javax.swing.JTextField[] textBoxes = {fcfsProcess1,fcfsProcess2,fcfsProcess3,fcfsProcess4,fcfsProcess5};// We will use 5 processes for now
        boolean invalid = false; // Executes First Come FIrst Serve
        fcfsWaitTime.setText("Average Waiting Time: ");
        fcfsTurnAround.setText("Average Turnaround:  ");
        for (int i = 0; i < textBoxes.length; i++){
            if (textBoxes[i].getText().equalsIgnoreCase("") || !isnumber(textBoxes[i].getText())) { // Checks for nan
                JOptionPane.showMessageDialog(rootPane, "Process " + i + " has an invalid burst time", "Invalid Burst Time", WARNING_MESSAGE);
                invalid = true;
            }
        }
        
        if (!invalid){
            fcfsTurnAround.setText(fcfsTurnAround.getText() + df.format(ComputeTurnAroundFCFS(textBoxes,false)) + " ms");
        }
    }//GEN-LAST:event_fcfsExecuteActionPerformed

    private void sjfProcess2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sjfProcess2ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_sjfProcess2ActionPerformed

    private void sjfProcess5ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sjfProcess5ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_sjfProcess5ActionPerformed

    private void sjfRandomizeMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_sjfRandomizeMouseClicked
        // TODO add your handling code here:
    }//GEN-LAST:event_sjfRandomizeMouseClicked

    private void sjfRandomizeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sjfRandomizeActionPerformed
        
        Random randInt = new Random();
        int min = 1;
        int max = 20;

        sjfProcess1.setText(String.valueOf(randInt.nextInt((max - min) + 1) + min));
        sjfProcess2.setText(String.valueOf(randInt.nextInt((max - min) + 1) + min));
        sjfProcess3.setText(String.valueOf(randInt.nextInt((max - min) + 1) + min));
        sjfProcess4.setText(String.valueOf(randInt.nextInt((max - min) + 1) + min));
        sjfProcess5.setText(String.valueOf(randInt.nextInt((max - min) + 1) + min));
        
    }//GEN-LAST:event_sjfRandomizeActionPerformed

    private void sjfResetActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sjfResetActionPerformed
        sjfProcess1.setText("");
        sjfProcess2.setText("");
        sjfProcess3.setText("");
        sjfProcess4.setText("");
        sjfProcess5.setText("");
        sjfWaitTime.setText("Average Waiting Time: ");
        sjfTurnAround.setText("Average Turnaround:  ");
        sjfProgress.removeAll();
        sjfProgress.invalidate();
        sjfProgress.revalidate();
        sjfProgress.repaint();
        
        if (numLbls.size() > 1){
            for(int i = 0; i < numLbls.size(); i++){
                numLbls.get(i).setVisible(false);
            }
        }
    }//GEN-LAST:event_sjfResetActionPerformed

    private void sjfExecuteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_sjfExecuteActionPerformed
        javax.swing.JTextField[] textBoxes = {sjfProcess1,sjfProcess2,sjfProcess3,sjfProcess4,sjfProcess5};// We will use 5 processes for now
        boolean invalid = false; // Executes Shortest Job first
        sjfWaitTime.setText("Average Waiting Time: ");
        sjfTurnAround.setText("Average Turnaround:  ");
        for (int i = 0; i < textBoxes.length; i++){
            if (textBoxes[i].getText().equalsIgnoreCase("") || !isnumber(textBoxes[i].getText())) { // Checks for nan
                JOptionPane.showMessageDialog(rootPane, "Process " + i + " has an invalid burst time", "Invalid Burst Time", WARNING_MESSAGE);
                invalid = true;
            }
        }
        
        if (!invalid){
            sjfTurnAround.setText(sjfTurnAround.getText() + df.format(ComputeTurnAroundSJF(textBoxes)) + " ms");
        }
    }//GEN-LAST:event_sjfExecuteActionPerformed

    private static boolean isnumber(String string){ // Easy helper method to convert strings to numbers
        try{
            Integer.parseInt(string);
            return true;
        }catch(NumberFormatException  e){
            return false;
        }
    }
    
    // private double Lerp(double frac, double start, double end){ // Provides a nice animation 
    //    return frac*(end - start) + start;
    // }
    
    private String FindProcessNum(int num,javax.swing.JTextField[] txtBoxes, String[] current){ // Helps us find the process ID of each box
        String lookFor = (String.valueOf(num));
        String processID = null;
        
        for(int i = 0; i < txtBoxes.length; i++){
            if (txtBoxes[i].getText().equalsIgnoreCase(lookFor) & !Arrays.asList(current).contains("P"+(i+1))){
                processID = "P"+(i+1);
            }
        }
     
        return processID;  
    }
    
    private void drawChartGeneric(Integer[] info, javax.swing.JTextField[] txtBoxes, String name){
        // In this method, we will be drawing a gantt chart
        // Easiest way to explain it is that we have an array of x numbers which is then visuaulised as blocks
        // The blocks will then size accordingly to the panel they are parent to, this only works for SJF and SCFC
        javax.swing.JPanel barRef = null;
        String[] collection = new String[txtBoxes.length];
        // Random randInt = new Random();
        int loc = 0;
        int addedSum = 0;
        ArrayList<JPanel> storedBlocks = new ArrayList();
        
        if (name.equalsIgnoreCase("sjf")){
            barRef = sjfProgress;
        }else if (name.equalsIgnoreCase("fcfs")){
            barRef = fcfsProgress;
        }
        
        
        if (barRef == null){
            JOptionPane.showMessageDialog(rootPane, "Progress Bar ref was invalid");
            return;
        }
        
        barRef.removeAll();
        barRef.invalidate();
        barRef.revalidate();
        barRef.repaint();
        
        if (numLbls != null){
            for (int i = 0; i < numLbls.size(); i++){
                    try{
                        barRef.getParent().remove(numLbls.get(i));
                    }catch(NullPointerException e){
                        System.out.println(e.getLocalizedMessage());
                    }
            }
        }
        

        for (Integer sum : info) {
            addedSum = addedSum + sum;
        }
        
        double maxWidthPerBox = (barRef.getWidth()/addedSum);
        int count = 0;
        
        for (int i = 0; i < info.length; i++){
           //Color randomColor = new Color(randInt.nextInt(256),randInt.nextInt(256),randInt.nextInt(256));  Random colors look weird
           javax.swing.JPanel block = new javax.swing.JPanel();
           barRef.add(block);
           block.setBackground(randomColors[i]);
           block.setSize((int) ((info[i]*maxWidthPerBox)+10), barRef.getHeight());
           block.setLocation(loc, 0);
           block.setVisible(true);
           javax.swing.JLabel process = new javax.swing.JLabel(FindProcessNum(info[i],txtBoxes,collection));
           javax.swing.JLabel time = new javax.swing.JLabel(String.valueOf(info[i]+count));
           numLbls.add(time);
           barRef.getParent().add(time);
           time.setSize(40, 10);
           time.setLocation(barRef.getX()+loc, barRef.getY()+35);
           time.setVisible(true);
           time.setForeground(new Color(255,255,255));
           collection[i] = FindProcessNum(info[i],txtBoxes,collection);
           block.add(process);
           process.setSize(block.getWidth(), HEIGHT);
           process.setVisible(true);
           loc = (int) (loc + (info[i]*maxWidthPerBox) + 10);
           storedBlocks.add(block);
           count = count + info[i];
        }
        
         double summedSize = 0;
        int index = 0;
        boolean sizedRight = false;

        for(int i = 0; i < storedBlocks.size(); i++){
            summedSize = summedSize + storedBlocks.get(i).getWidth();
        }

        if (summedSize < barRef.getWidth()){
            while(!sizedRight){
                JPanel attBlock = storedBlocks.get(index);
                if (index == 0){
                    attBlock.setBounds(attBlock.getX(), attBlock.getY(), attBlock.getWidth() + 1, attBlock.getHeight());
                    summedSize = summedSize + 1;
                }else{
                    attBlock.setBounds(attBlock.getX() + 1, attBlock.getY(), attBlock.getWidth() + 1, attBlock.getHeight());
                    summedSize = summedSize + 1;
                }

                index = index + 1;
                System.out.println("inc width based off dec " + summedSize + "!= " +  barRef.getWidth() );
                if (index > storedBlocks.size()-1){
                    index = 0;
                }

                if (summedSize+2 > barRef.getWidth()){
                    sizedRight = true;
                }
            }
        }
        
    }
    
     private void drawChartRobin(javax.swing.JTextField[] info, int slice, int max){
        javax.swing.JPanel barRef = rrProgress; // This method is designed for round robin so we can assign the ref here
        ArrayList<JPanel> storedBlocks = new ArrayList();
        // Random randInt = new Random();
        // Robin works the same except we use the slice to always make the box either 4 wide or the length wide
        int loc = 0;
        
        barRef.removeAll();
        barRef.invalidate();
        barRef.revalidate();
        barRef.repaint(); // Repaints the bar to show info
        
        if (numLbls != null){
            for (int i = 0; i < numLbls.size(); i++){
                if (numLbls.get(i) != null){    
                    try{
                            barRef.getParent().remove(numLbls.get(i));
                        }catch(NullPointerException e){
                            System.out.println(e.getLocalizedMessage());
                        }
                }
            }
        }
        
        double maxWidthPerBox = (barRef.getWidth()/max);
        int count = 0;
        int itt = 0;
        int lblTrack = 0;
        Integer[] nums = new Integer[info.length];
        boolean done = false;
        
        for (int i = 0; i < info.length; i++){
            nums[i] = Integer.parseInt(info[i].getText());
        }
        
       while(!done){
           //Color randomColor = new Color(randInt.nextInt(256),randInt.nextInt(256),randInt.nextInt(256));  Random colors look weird
          javax.swing.JLabel time = new javax.swing.JLabel();
           if (nums[itt] > 0){
            
            int burst = nums[itt];
            javax.swing.JPanel block = new javax.swing.JPanel();
            barRef.add(block);
            block.setBackground(randomColors[itt]);
            block.setLocation(loc, 0);
            if (burst - slice > 0){
                System.out.println(burst);
               block.setSize((int) ((slice*maxWidthPerBox+1)), barRef.getHeight()); // We are adding an offset because sometimes everything will nto add up
               nums[itt] = burst - slice;
               loc = (int) (loc + (slice*maxWidthPerBox+1));
               time.setText(String.valueOf(slice+count));
               count = count + slice;
               
            }else if (burst - slice <= 0){
               System.out.println(burst);
               block.setSize((int) ((burst*maxWidthPerBox+1)), barRef.getHeight());
               nums[itt] = 0;
               loc = (int) (loc + (burst*maxWidthPerBox+1));
               time.setText(String.valueOf(burst+count));
               count = count + burst;
               
            }
            
            block.setVisible(true);
            javax.swing.JLabel process = new javax.swing.JLabel("P"+(itt+1));
            numLbls.add(time);
            barRef.getParent().add(time);
            time.setSize(40, 10);
            time.setLocation(barRef.getX()+loc, barRef.getY()+35);
            time.setVisible(true);
            time.setForeground(new Color(255,255,255));
            block.add(process);
            process.setSize(block.getWidth(), HEIGHT);
            process.setVisible(true);
            lblTrack = lblTrack + 1;
            storedBlocks.add(block);
           }
           
            itt = itt + 1;
            if (itt > info.length-1){
                itt = 0;
            }
            
            int doneCheck = 0;
            
            for (Integer num : nums) {
                if (num <= 0) {
                    doneCheck = doneCheck + 1;
                }
            }
            
            if (doneCheck == nums.length){
                done = true;
                double summedSize = 0;
                int index = 0;
                boolean sizedRight = false;
                
                for(int i = 0; i < storedBlocks.size(); i++){
                    summedSize = summedSize + storedBlocks.get(i).getWidth();
                }
                
                if (summedSize < barRef.getWidth()){
                    while(!sizedRight){
                        JPanel attBlock = storedBlocks.get(index);
                        if (index == 0){
                            attBlock.setBounds(attBlock.getX(), attBlock.getY(), attBlock.getWidth() + 1, attBlock.getHeight());
                            summedSize = summedSize + 1;
                        }else{
                            attBlock.setBounds(attBlock.getX() + 1, attBlock.getY(), attBlock.getWidth() + 1, attBlock.getHeight());
                            summedSize = summedSize + 1;
                        }
                        
                        index = index + 1;
                        System.out.println("inc width based off dec " + summedSize + "!= " +  barRef.getWidth() );
                        if (index > storedBlocks.size()-1){
                            index = 0;
                        }
                        
                        if (summedSize > barRef.getWidth()){
                            sizedRight = true;
                        }
                    }
                }
            }
        }
        
    }
    
    private double ComputeTurnAroundSJF(JTextField[] textBoxes){ // Computes the turn around for Shortest Job First
        Integer[] values = new Integer[textBoxes.length];
        
        for(int i = 0; i < textBoxes.length; i++){
            values[i] = Integer.parseInt(textBoxes[i].getText());
        }
        
        Arrays.sort(values); // Short the values for the sortest
        ComputeWaitingTimeSJF(values);
        drawChartGeneric(values,textBoxes,"sjf");
        return ComputeTurnAroundFCFS(textBoxes,true);
    }
    
    private double ComputeTurnAroundFCFS(JTextField[] textBoxes,boolean sjf){ // Since SJF and FCFS have the same turnaround time, we can use this
        int turnTime = 0; // We could do the wait time in this method too but lets be organized
        int finalTime = 0;
        Integer[] storedArr = new Integer[textBoxes.length];
        Integer[] nonAdded = new Integer[textBoxes.length];
        
        for (int i = 0; i < textBoxes.length; i++){
            storedArr[i] = turnTime + Integer.parseInt(textBoxes[i].getText());
            turnTime = turnTime + Integer.parseInt(textBoxes[i].getText());
            nonAdded[i] = Integer.parseInt(textBoxes[i].getText());
        }
        
        for (int i = 0; i < storedArr.length; i++){
            finalTime = finalTime + storedArr[i];
        }
        
        if (!sjf){
             drawChartGeneric(nonAdded,textBoxes,"fcfs");
             ComputeWaitTimeFCSC(storedArr);
        }
        
        return (finalTime / storedArr.length);
    }
    
    private void ComputeWaitTimeFCSC(Integer[] finalTimes){
        int time = 0;
        for (int i = 0; i < finalTimes.length - 1; i++){ // Subtract one for the wait time
            time = time + finalTimes[i];
        }
        
         fcfsWaitTime.setText(fcfsWaitTime.getText() + df.format(time/finalTimes.length) + " ms");
    }
    
    private void ComputeWaitingTimeSJF(Integer[] sortedTimes){
        int summedQueue = 0;
        int finalNum = 0;
        Integer[] refQueue = new Integer[sortedTimes.length-1];
        
        for (int i = 0; i < sortedTimes.length-1; i++){
            summedQueue = summedQueue + sortedTimes[i];
            refQueue[i] = summedQueue;
        }
        
        for (int i = 0; i < refQueue.length; i++){
           finalNum = finalNum + refQueue[i];
        }
        
        sjfWaitTime.setText(sjfWaitTime.getText() + df.format(finalNum/sortedTimes.length) + " ms");
    }
    
    private void ComputeWaitTimeRoundRobin(Integer subNum[], Integer bArray[]){
        // Computes the wait time
        double finalTime = 0;
        
        for(int i = 0; i < bArray.length; i++){
            finalTime = finalTime + (subNum[i] - bArray[i]);
        }
        
        rrlblWait.setText(rrlblWait.getText() + df.format(finalTime/bArray.length) + " ms");
    }
    
     private double ComputeTurnAroundRoundRobin(int slice,JTextField[] textBoxes) {
         // This method does all of the heavy work, it will compute the turnaround time which will then
         // Pass an array to the ComputeWaitTime method to compute the wait time
         int waitTime = 0;
         int maxTime = 0;
         int results = textBoxes.length;
         boolean allFinished = false;   
         double finalResult = 0;
         Integer[] finishedArr = new Integer[results]; // Using a hash map is probably better but for simplictiy sake we will use the array index as the process id
         Integer[] burstTimeMod = new Integer[results]; // Table used for modifiying the burst times
         Integer[] burstRef = new Integer[results]; // This is used to keep as an easy reference
         int whileItt = 0;
         for (int i = 0; i < textBoxes.length; i++){
            burstTimeMod[i] = Integer.parseInt(textBoxes[i].getText());
            burstRef[i] = Integer.parseInt(textBoxes[i].getText());
            maxTime = maxTime + Integer.parseInt(textBoxes[i].getText());
         } 
        
        do{
            if (burstTimeMod[whileItt] > 0){
                int burst = burstTimeMod[whileItt]; // Store ref
                burstTimeMod[whileItt] = burst - slice; // Edit
                if (burstTimeMod[whileItt] == 0){ // 0? Good!
                     waitTime = waitTime + slice;
                     finishedArr[whileItt] = waitTime;
                }
                else if(burstTimeMod[whileItt] < 0){ // less than 0 subtracts the ref with the slice
                    waitTime = waitTime + burst;
                    finishedArr[whileItt] = waitTime;
                }else{
                    waitTime = waitTime + slice;
                }
            }
           boolean good2Go = true;
           
           for (int i = 0; i < finishedArr.length; i++){
               if (finishedArr[i] == null){
                   good2Go = false;
               }        
           }
           
           if (good2Go){
               allFinished = true;
           }else{
                whileItt = whileItt + 1;
                if (whileItt > textBoxes.length-1){
                    whileItt = 0;
                }
           }
            
        }while(!allFinished);
        
        for (int i = 0; i < finishedArr.length; i++){
            finalResult = finalResult + finishedArr[i];
        }
        
        drawChartRobin(textBoxes,slice,maxTime);
        ComputeWaitTimeRoundRobin(finishedArr, burstRef);
        
        return (finalResult / finishedArr.length);
    }
    
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Sched.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Sched.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Sched.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Sched.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Sched().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private java.awt.Label dirLbl;
    private java.awt.Label dirLbl1;
    private java.awt.Label dirLbl2;
    private java.awt.Label dirLbl3;
    private java.awt.Label dirLbl4;
    private java.awt.Label dirLblClass;
    private javax.swing.JButton fcfsExecute;
    private java.awt.Label fcfsLbl;
    private javax.swing.JTextField fcfsProcess1;
    private javax.swing.JTextField fcfsProcess2;
    private javax.swing.JTextField fcfsProcess3;
    private javax.swing.JTextField fcfsProcess4;
    private javax.swing.JTextField fcfsProcess5;
    private javax.swing.JPanel fcfsProgress;
    private javax.swing.JButton fcfsRandom;
    private javax.swing.JButton fcfsReset;
    private javax.swing.JPanel fcfsTab;
    private javax.swing.JLabel fcfsTurnAround;
    private javax.swing.JLabel fcfsWaitTime;
    private javax.swing.JTabbedPane jTabbedPane1;
    private java.awt.Label label1;
    private javax.swing.JLabel lblfcfsProcess1;
    private javax.swing.JLabel lblfcfsProcess2;
    private javax.swing.JLabel lblfcfsProcess3;
    private javax.swing.JLabel lblfcfsProcess4;
    private javax.swing.JLabel lblfcfsProcess5;
    private java.awt.Label lbllfcfsMaxBurst;
    private java.awt.Label lbllfcfsState;
    private javax.swing.JLabel lblrrProcess1;
    private javax.swing.JLabel lblrrProcess2;
    private javax.swing.JLabel lblrrProcess3;
    private javax.swing.JLabel lblrrProcess4;
    private javax.swing.JLabel lblrrProcess5;
    private javax.swing.JLabel lblrrQuant;
    private javax.swing.JPanel rbTab;
    private java.awt.Label rndLbl;
    private javax.swing.JButton rrExecute;
    private java.awt.Label rrMaxBurst;
    private java.awt.Label rrMaxQuant;
    private javax.swing.JTextField rrProcess1;
    private javax.swing.JTextField rrProcess2;
    private javax.swing.JTextField rrProcess3;
    private javax.swing.JTextField rrProcess4;
    private javax.swing.JTextField rrProcess5;
    private javax.swing.JPanel rrProgress;
    private javax.swing.JTextField rrQuant;
    private javax.swing.JButton rrRandom;
    private javax.swing.JButton rrReset;
    private java.awt.Label rrState;
    private javax.swing.JLabel rrlblTurn;
    private javax.swing.JLabel rrlblWait;
    private java.awt.Label sjfBTMax;
    private javax.swing.JButton sjfExecute;
    private javax.swing.JTextField sjfProcess1;
    private javax.swing.JTextField sjfProcess2;
    private javax.swing.JTextField sjfProcess3;
    private javax.swing.JTextField sjfProcess4;
    private javax.swing.JTextField sjfProcess5;
    private javax.swing.JPanel sjfProgress;
    private javax.swing.JButton sjfRandomize;
    private javax.swing.JButton sjfReset;
    private java.awt.Label sjfState;
    private javax.swing.JPanel sjfTab;
    private javax.swing.JLabel sjfTurnAround;
    private javax.swing.JLabel sjfWaitTime;
    private javax.swing.JLabel sjflblProcess1;
    private javax.swing.JLabel sjflblProcess2;
    private javax.swing.JLabel sjflblProcess3;
    private javax.swing.JLabel sjflblProcess4;
    private javax.swing.JLabel sjflblProcess5;
    private java.awt.Label welcomeLbl;
    private javax.swing.JPanel welcomeTab;
    // End of variables declaration//GEN-END:variables
    private final Color[] randomColors = {new Color(65,131,215),new Color(228,251,254), new Color(38,166,91), new Color(27,163,156), new Color(248,148,6)};
    ArrayList<JLabel> numLbls = new ArrayList();
}
